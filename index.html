<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>ðŸ“Š Binance Style â€“ Live Scanner PRO v5 (velas + sonido + notificaciones)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #050714;
      --bg-soft: #070a1c;
      --panel: #0b0e1e;
      --card: #111523;
      --border: #1f2933;
      --accent: #f3ba2f;
      --accent-soft: rgba(243, 186, 47, 0.14);
      --accent-strong: #ffce3e;
      --green: #0ecb81;
      --green-soft: rgba(14, 203, 129, 0.15);
      --red: #f6465d;
      --red-soft: rgba(246, 70, 93, 0.17);
      --muted: #848e9c;
      --text: #eaecef;
      --text-soft: #b7bdc6;
      --shadow-soft: 0 22px 50px rgba(0, 0, 0, 0.85);
      --radius-lg: 18px;
      --radius-md: 12px;
      --radius-pill: 999px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      background: radial-gradient(circle at top, #111827 0, #050714 40%, #000 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
    }

    body {
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 14px;
    }

    .app-shell {
      width: 100%;
      max-width: 1220px;
      margin: auto;
      background: radial-gradient(circle at top left, #0b0e1e 0, #020308 55%);
      border-radius: 24px;
      border: 1px solid rgba(51, 65, 85, 0.9);
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* HEADER */
    header {
      padding: 14px 18px 8px;
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(16px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .brand-icon {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      background: radial-gradient(circle at 30% 0, var(--accent-strong) 0, var(--accent) 40%, #c98d0c 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 25px rgba(243, 186, 47, 0.85);
      font-size: 18px;
    }

    .brand-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .brand-title {
      font-weight: 600;
      letter-spacing: 0.05em;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .brand-title span.highlight {
      color: var(--accent-strong);
    }

    .brand-subtitle {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .badge-live {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(78, 182, 133, 0.8);
      background: linear-gradient(135deg, rgba(14,203,129,0.12), rgba(9, 118, 80, 0.1));
      font-size: 11px;
      color: #c4f7df;
    }

    .dot-pulse {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--green);
      box-shadow: 0 0 10px rgba(14, 203, 129, 1);
      position: relative;
    }

    .dot-pulse::after {
      content: "";
      position: absolute;
      inset: -4px;
      border-radius: inherit;
      border: 1px solid rgba(14,203,129,0.8);
      animation: ping 1.3s cubic-bezier(0,0,0.2,1) infinite;
    }

    @keyframes ping {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(2.1); opacity: 0; }
    }

    .connection-status {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(75, 85, 99, 0.8);
      color: var(--text-soft);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: radial-gradient(circle at top left, rgba(148,163,184,0.18), rgba(7, 10, 28, 0.9));
    }

    .connection-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #f97316;
    }

    .connection-dot.ok {
      background: var(--green);
      box-shadow: 0 0 10px rgba(14,203,129,0.9);
    }

    .connection-dot.off {
      background: var(--red);
      box-shadow: 0 0 10px rgba(246,70,93,0.8);
    }

    /* TOOLBAR */
    .toolbar {
      padding: 8px 18px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(to bottom, rgba(17,24,39,0.75), rgba(5,7,20,0.98));
    }

    .toolbar-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 3px;
      font-size: 11px;
      color: var(--muted);
    }

    .field label {
      text-transform: uppercase;
      letter-spacing: 0.13em;
    }

    .field-row {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    select, button {
      font-family: inherit;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: radial-gradient(circle at top, #141823, #050714);
      color: var(--text);
      font-size: 13px;
      padding: 7px 14px;
      outline: none;
      min-width: 0;
    }

    select {
      padding-right: 28px;
      appearance: none;
      background-image:
        linear-gradient(45deg, transparent 50%, #6b7280 50%),
        linear-gradient(135deg, #6b7280 50%, transparent 50%);
      background-position:
        calc(100% - 13px) 11px,
        calc(100% - 8px) 11px;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
    }

    button {
      border-radius: var(--radius-pill);
      border: 1px solid rgba(243, 186, 47, 0.8);
      background: radial-gradient(circle at top left, var(--accent-strong), #bb8b10);
      color: #05030a;
      font-weight: 600;
      letter-spacing: 0.06em;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding-inline: 18px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(243, 186, 47, 0.8);
      text-transform: uppercase;
    }

    button span.icon { font-size: 15px; }

    button:hover {
      filter: brightness(1.06);
      transform: translateY(-1px);
      box-shadow: 0 0 26px rgba(243,186,47,1);
    }

    button:active {
      transform: translateY(0);
      filter: brightness(0.98);
      box-shadow: 0 0 14px rgba(243,186,47,0.7);
    }

    /* MAIN GRID */
    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 14px;
      padding: 14px 14px 16px;
    }

    @media (max-width: 880px) {
      main { grid-template-columns: minmax(0, 1fr); }
    }

    .card {
      background: radial-gradient(circle at top left, #141823, #050714);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(55, 65, 81, 0.9);
      box-shadow: 0 18px 40px rgba(0,0,0,0.85);
      padding: 12px 12px 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at top right, rgba(243,186,47,0.12), transparent 55%),
        radial-gradient(circle at bottom left, rgba(14,203,129,0.12), transparent 55%);
      opacity: 0.85;
      pointer-events: none;
    }

    .card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 6px;
      position: relative;
      z-index: 1;
    }

    .card-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .pill {
      font-size: 10px;
      padding: 2px 7px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(148, 163, 184, 0.7);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .card-body {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* GRID METRICS */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    @media (max-width: 640px) {
      .metrics-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    .metric {
      padding: 8px 10px;
      border-radius: 14px;
      background: radial-gradient(circle at top, #101320, #060816);
      border: 1px solid rgba(55, 65, 81, 0.9);
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-height: 62px;
    }

    .metric.primary { grid-column: span 2; }

    .metric-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.13em;
    }

    .metric-value {
      font-size: 22px;
      line-height: 1.1;
      font-weight: 600;
    }

    .metric-value.sm { font-size: 15px; }

    .metric-sub {
      font-size: 11px;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .chip {
      border-radius: var(--radius-pill);
      padding: 2px 7px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: var(--muted);
    }

    .metric-variation {
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .metric-variation.up { color: var(--green); }
    .metric-variation.down { color: var(--red); }
    .metric-variation.neutral { color: var(--muted); }

    .dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
    }

    .dot.green { background: var(--green); box-shadow: 0 0 8px rgba(14,203,129,0.9); }
    .dot.red   { background: var(--red); box-shadow: 0 0 8px rgba(246,70,93,0.9); }
    .dot.gray  { background: #6b7280; }

    /* ENTRY MODE PANEL */
    .entry-mode {
      margin-top: 4px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(55, 65, 81, 0.95);
      background: radial-gradient(circle at left, rgba(243,186,47,0.12), rgba(5,7,20,1));
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1.4fr);
      gap: 10px;
      align-items: center;
    }

    @media (max-width: 780px) {
      .entry-mode { grid-template-columns: minmax(0, 1fr); }
    }

    .entry-main {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .entry-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .entry-status {
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .entry-status.long {
      color: var(--green);
      text-shadow: 0 0 12px rgba(14,203,129,0.9);
    }

    .entry-status.short {
      color: var(--red);
      text-shadow: 0 0 12px rgba(246,70,93,0.95);
    }

    .entry-status.flat {
      color: var(--accent-strong);
    }

    .entry-sub {
      font-size: 11px;
      color: var(--text-soft);
    }

    .entry-conditions {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4px 10px;
    }

    .cond-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      padding: 4px 7px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(55,65,81,0.9);
      background: #050814;
      color: var(--muted);
    }

    .cond-pill.ok {
      border-color: rgba(14,203,129,0.9);
      background: var(--green-soft);
      color: #d1fae5;
    }

    .cond-pill.bad {
      border-color: rgba(246,70,93,0.9);
      background: var(--red-soft);
      color: #fee2e2;
    }

    .cond-icon {
      font-size: 12px;
    }

    /* CANDLE CHART */
    .chart-wrapper {
      margin-top: 6px;
      border-radius: 16px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: radial-gradient(circle at top, #050814, #020309);
      padding: 4px 6px 2px;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
      padding-inline: 4px;
    }

    .chart-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .chart-sub {
      font-size: 10px;
      color: var(--text-soft);
    }

    #candleCanvas {
      width: 100%;
      height: 210px;
      display: block;
      border-radius: 12px;
    }

    /* STATS / TABLE */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 6px;
    }

    @media (max-width: 640px) {
      .stats-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    .stat-card {
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.95);
      background: radial-gradient(circle at top, #141823, #050714);
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-height: 50px;
    }

    .stat-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .stat-value {
      font-size: 16px;
      font-weight: 600;
    }

    .stat-sub { font-size:10px; color:var(--text-soft); }
    .stat-value.green { color: var(--green); }
    .stat-value.red   { color: var(--red); }

    /* NOTIFICACIONES */
    .notifications-panel {
      margin-bottom: 6px;
      padding: 6px 8px 6px;
      border-radius: 14px;
      border: 1px solid rgba(55, 65, 81, 0.95);
      background: radial-gradient(circle at left, rgba(15,23,42,0.95), #020309);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .notifications-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 2px;
    }

    .notifications-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .notif-clear-btn {
      border-radius: var(--radius-pill);
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15,23,42,0.9);
      color: #9ca3af;
      font-size: 10px;
      padding: 3px 8px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
    }

    .notif-clear-btn:hover {
      filter: brightness(1.1);
      border-color: rgba(148,163,184,0.9);
    }

    .notifications-list {
      max-height: 110px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .notif-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      font-size: 11px;
      padding: 4px 6px;
      border-radius: 10px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(31, 41, 55, 0.9);
    }

    .notif-badge {
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      flex-shrink: 0;
    }

    .notif-badge.long {
      background: var(--green-soft);
      color: #d1fae5;
      border: 1px solid rgba(14,203,129,1);
    }

    .notif-badge.short {
      background: var(--red-soft);
      color: #fee2e2;
      border: 1px solid rgba(246,70,93,1);
    }

    .notif-badge.flat {
      background: var(--accent-soft);
      color: var(--accent-strong);
      border: 1px solid rgba(243,186,47,0.9);
    }

    .notif-body {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .notif-text {
      color: var(--text-soft);
    }

    .notif-meta {
      font-size: 10px;
      color: #9ca3af;
    }

    .notif-empty {
      font-size: 11px;
      color: #6b7280;
      padding: 2px 2px;
    }

    .signals-table-wrapper {
      max-height: 230px;
      overflow: hidden auto;
      border-radius: 12px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: radial-gradient(circle at top left, #101320, #050714);
    }

    table { width:100%; border-collapse:collapse; font-size:11px; }

    thead {
      position: sticky;
      top: 0;
      z-index: 2;
      background: linear-gradient(to bottom, #0b0f1c, #050714);
    }

    th, td {
      padding: 6px 10px;
      text-align: left;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      white-space: nowrap;
    }

    th {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
      font-weight: 500;
      font-size: 10px;
    }

    tbody tr:nth-child(even) { background: rgba(12,16,32,0.95); }
    tbody tr:hover           { background: rgba(55,65,81,0.9); }

    .badge {
      padding: 2px 8px;
      border-radius: var(--radius-pill);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .badge-buy {
      background: var(--green-soft);
      color: #d1fae5;
      border: 1px solid rgba(14,203,129,1);
    }

    .badge-sell {
      background: var(--red-soft);
      color: #fee2e2;
      border: 1px solid rgba(246,70,93,1);
    }

    .badge-flat {
      background: var(--accent-soft);
      color: var(--accent-strong);
      border: 1px solid rgba(243,186,47,0.9);
    }

    .badge-strat {
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(55,65,81,0.9);
      color: var(--text-soft);
    }

    /* SIGNAL BANNER (Ãºltima seÃ±al) */
    .signal-banner {
      margin-top: 4px;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(55, 65, 81, 0.95);
      background: radial-gradient(circle at right, rgba(243,186,47,0.1), rgba(5,7,20,1));
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
    }

    .signal-banner .tag {
      padding: 4px 10px;
      border-radius: var(--radius-pill);
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .tag-buy {
      background: var(--green-soft);
      border: 1px solid rgba(14,203,129,1);
      color: #d1fae5;
    }

    .tag-sell {
      background: var(--red-soft);
      border: 1px solid rgba(246,70,93,1);
      color: #fee2e2;
    }

    .tag-flat {
      background: var(--accent-soft);
      border: 1px solid rgba(243,186,47,0.9);
      color: var(--accent-strong);
    }

    .signal-detail { display:flex; flex-direction:column; gap:2px; }
    .signal-detail span { font-size:11px; color:var(--text-soft); }

    /* FOOTER */
    footer {
      padding: 8px 14px 10px;
      border-top: 1px solid var(--border);
      font-size: 11px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      background: radial-gradient(circle at bottom, #020308, #050714);
    }

    .footer-section {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .footer-section span.label {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 10px;
      color: #6b7280;
    }

    .mono {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .hint { color:#9ca3af; }
    .hint strong { color:#eaecef; font-weight:600; }

    ::-webkit-scrollbar { width:6px; height:6px; }
    ::-webkit-scrollbar-track { background:#020308; }
    ::-webkit-scrollbar-thumb { background:#4b5563; border-radius:999px; }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="brand">
        <div class="brand-icon">â‚¿</div>
        <div class="brand-text">
          <div class="brand-title">
            LIVE<span class="highlight">SCANNER</span> PRO
          </div>
          <div class="brand-subtitle">BINANCE STYLE Â· EMAS Â· ATR Â· ELLIOTT Â· VELAS Â· SONIDO</div>
        </div>
      </div>
      <div class="header-right">
        <div class="badge-live">
          <div class="dot-pulse"></div>
          EN TIEMPO REAL
        </div>
        <div class="connection-status">
          <div id="statusDot" class="connection-dot off"></div>
          <span id="statusText">Desconectado</span>
        </div>
      </div>
    </header>

    <div class="toolbar">
      <div class="toolbar-group">
        <div class="field">
          <label>SÃ­mbolo</label>
          <div class="field-row">
            <select id="symbolSelect">
              <option value="BTCUSDT">BTC/USDT</option>
              <option value="ETHUSDT">ETH/USDT</option>
              <option value="BNBUSDT">BNB/USDT</option>
              <option value="PEPEUSDT">PEPE/USDT</option>
              <option value="SOLUSDT">SOL/USDT</option>
              <option value="LINKUSDT">LINK/USDT</option>
              <option value="ADAUSDT">ADA/USDT</option>
              <option value="ZECUSDT">ZEC/USDT</option>
              <option value="DASHUSDT">DASH/USDT</option>
              <option value="MLNUSDT">MLN/USDT</option>
            </select>
          </div>
        </div>
        <div class="field">
          <label>Timeframe</label>
          <div class="field-row">
            <select id="intervalSelect">
              <option value="1m">1m</option>
              <option value="5m">5m</option>
              <option value="15m">15m</option>
              <option value="1h">1H</option>
              <option value="1d">1D</option>
            </select>
          </div>
        </div>
      </div>

      <div class="toolbar-group">
        <div class="field">
          <label>Setup</label>
          <div class="field-row">
            <span class="chip">EMAs + ATR Â· UT Â· Elliott asistente Â· Velas + Sonido</span>
          </div>
        </div>
        <button id="connectBtn">
          <span class="icon">ðŸš€</span>
          <span>Conectar / Reset</span>
        </button>
      </div>
    </div>

    <main>
      <!-- LEFT: snapshot + modo + chart -->
      <section class="card">
        <div class="card-header">
          <div class="card-title">Snapshot de mercado</div>
          <div class="pill" id="symbolLabel">BTCUSDT Â· 1M</div>
        </div>
        <div class="card-body">
          <div class="metrics-grid">
            <div class="metric primary">
              <div class="metric-label">Precio actual</div>
              <div id="priceValue" class="metric-value">â€“ â€“ â€“</div>
              <div class="metric-sub">
                <span id="priceChange" class="metric-variation neutral">
                  <span class="dot gray"></span>
                  Sin variaciÃ³n
                </span>
              </div>
            </div>
            <div class="metric">
              <div class="metric-label">Cierre vela actual</div>
              <div id="lastClose" class="metric-value sm mono">â€“ â€“ â€“</div>
              <div class="metric-sub">
                <span id="lastCandleInfo">Esperando datosâ€¦</span>
              </div>
            </div>
            <div class="metric">
              <div class="metric-label">EMA 9 vs EMA 21</div>
              <div class="metric-value sm">
                <span id="ema9Value" class="mono">â€“ â€“ â€“</span>
                &nbsp;/&nbsp;
                <span id="ema21Value" class="mono">â€“ â€“ â€“</span>
              </div>
              <div class="metric-sub">
                <span id="emaState">Sin cÃ¡lculo suficienteâ€¦</span>
              </div>
            </div>
          </div>

          <!-- MODO DE ENTRADA -->
          <div class="entry-mode">
            <div class="entry-main">
              <div class="entry-label">Modo de entrada (planetas alineados)</div>
              <div id="entryStatus" class="entry-status flat">NO OPERAR</div>
              <div id="entrySub" class="entry-sub">
                EMAs, UT y ATR definen el modo. Elliott suma contexto. Sonido al entrar LONG/SHORT.
              </div>
            </div>
            <div class="entry-conditions">
              <div id="condEma" class="cond-pill">
                <span class="cond-icon">â€¢</span>
                <span>EMAs alineadas</span>
              </div>
              <div id="condUT" class="cond-pill">
                <span class="cond-icon">â€¢</span>
                <span>Tendencia UT</span>
              </div>
              <div id="condPrice" class="cond-pill">
                <span class="cond-icon">â€¢</span>
                <span>Precio vs EMAs</span>
              </div>
              <div id="condAtr" class="cond-pill">
                <span class="cond-icon">â€¢</span>
                <span>Volatilidad (ATR)</span>
              </div>
              <div id="condElliott" class="cond-pill">
                <span class="cond-icon">â€¢</span>
                <span>Elliott (impulso/correcciÃ³n)</span>
              </div>
            </div>
          </div>

          <!-- ÃšLTIMA SEÃ‘AL -->
          <div class="signal-banner" id="signalBanner">
            <div id="signalTag" class="tag tag-flat">Sin seÃ±al</div>
            <div class="signal-detail">
              <span id="signalText">TodavÃ­a no se alinearon los planetas para entrar.</span>
              <span id="signalMeta" class="mono">â€“ â€“ â€“</span>
            </div>
          </div>

          <!-- GRÃFICO DE VELAS -->
          <div class="chart-wrapper">
            <div class="chart-header">
              <div class="chart-title">GrÃ¡fico de velas japonesas</div>
              <div class="chart-sub">Datos en vivo desde Binance (OHLC)</div>
            </div>
            <canvas id="candleCanvas"></canvas>
          </div>
        </div>
      </section>

      <!-- RIGHT: historial + stats + notificaciones -->
      <section class="card">
        <div class="card-header">
          <div class="card-title">Historial & estadÃ­sticas</div>
          <div class="pill">Confluencia EMAs + ATR Â· Elliott asistente Â· Sonoro</div>
        </div>
        <div class="card-body">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-label">SeÃ±ales</div>
              <div id="statSignals" class="stat-value">0</div>
              <div class="stat-sub">Total LONG + SHORT</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Trades</div>
              <div id="statTrades" class="stat-value">0</div>
              <div class="stat-sub">Se cierra al cambio de color</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Winrate</div>
              <div id="statWinrate" class="stat-value green">â€“</div>
              <div class="stat-sub">% trades con PnL &gt; 0</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">PnL promedio</div>
              <div id="statAvgPnl" class="stat-value">â€“</div>
              <div class="stat-sub">% por trade</div>
            </div>
          </div>

          <!-- NOTIFICACIONES DE TENDENCIA -->
          <div class="notifications-panel">
            <div class="notifications-header">
              <div class="notifications-title">Notificaciones de tendencia</div>
              <button id="clearNotifBtn" type="button" class="notif-clear-btn">Limpiar</button>
            </div>
            <div id="notificationsList" class="notifications-list">
              <div class="notif-empty">Sin notificaciones todavÃ­a.</div>
            </div>
          </div>

          <div class="signals-table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>Hora</th>
                  <th>Tipo</th>
                  <th>Estrategia</th>
                  <th>Precio</th>
                  <th>EMA9</th>
                  <th>EMA21</th>
                </tr>
              </thead>
              <tbody id="signalsBody"></tbody>
            </table>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <div class="footer-section">
        <span class="label">Stream</span>
        <span id="footerStream" class="mono">â€“</span>
      </div>
      <div class="footer-section">
        <span class="label">PosiciÃ³n</span>
        <span id="footerPosition" class="mono">Sin posiciÃ³n abierta</span>
      </div>
      <div class="footer-section">
        <span class="hint">
          GuardÃ¡ este archivo como <strong>scanner-binance-pro-v5-notificaciones.html</strong> y abrilo en el navegador.
        </span>
      </div>
    </footer>
  </div>

  <script>
    // ===== ESTADO GLOBAL =====
    let socket = null;
    let closes = [];
    let ema9 = null;
    let ema21 = null;
    let lastPrice = null;
    let prevEma9 = null;
    let prevEma21 = null;

    // Candles OHLC para el grÃ¡fico
    let candles = []; // {open, high, low, close, time}
    const MAX_CANDLES = 120;

    // ATR / UT style
    const ATR_PERIOD = 10;
    const ATR_MULT = 1.5;
    const ATR_MIN_PCT = 0.0015; // 0.15% del precio
    let atr = null;
    let prevClose = null;
    let utTrend = null; // "LONG" | "SHORT" | "FLAT"
    let utLine = null;

    // Confluencia: modo de entrada
    let entryMode = "NO_TRADE";     // "NO_TRADE" | "ONLY_LONG" | "ONLY_SHORT"
    let prevEntryMode = "NO_TRADE";

    // ZigZag / Elliott (solo informativo)
    const ZZ_THRESHOLD = 0.008; // 0.8%
    let zzLastDir = null;       // "up" | "down" | null
    let zzLastPrice = null;
    let zzLastTime = null;
    let zzPivots = [];          // { type: "H"|"L", price, time }
    let elliottBias = "NEUTRAL"; // "BULL" | "BEAR" | "NEUTRAL"

    // Backtest live
    let signals = []; // { type, price, ema9, ema21, ts, strategy }
    let trades = [];  // { side, entry, exit, pnlPct, tsEntry, tsExit }
    let openPosition = null; // { side, entryPrice, tsEntry }

    // Notifs
    let notifications = [];

    // Audio
    let audioCtx = null;
    function initAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
        }
      }
    }

    function beepOnce(freq = 880, durationMs = 150, volume = 0.15, startDelayMs = 0) {
      if (!audioCtx) return;
      const t0 = audioCtx.currentTime + startDelayMs / 1000;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, t0);
      gain.gain.linearRampToValueAtTime(volume, t0 + 0.01);
      gain.gain.linearRampToValueAtTime(0.0001, t0 + durationMs / 1000);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t0);
      osc.stop(t0 + durationMs / 1000 + 0.05);
    }

    function playAlert(signalType) {
      if (!audioCtx) return;
      if (signalType === "BUY") {
        beepOnce(950, 140, 0.18, 0);
        beepOnce(1050, 140, 0.18, 180);
      } else if (signalType === "SELL") {
        beepOnce(520, 120, 0.18, 0);
        beepOnce(480, 120, 0.18, 150);
        beepOnce(440, 140, 0.18, 300);
      }
    }

    // ===== HELPERS =====
    function formatNumber(num, decimals = 2) {
      if (num === null || num === undefined || Number.isNaN(num)) return "â€“";
      return Number(num).toLocaleString("en-US", {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals
      });
    }

    function formatPriceBySymbol(symbol, price) {
      if (price === null || price === undefined) return "â€“ â€“ â€“";
      const s = symbol.toUpperCase();
      if (s.endsWith("USDT")) {
        if (s.startsWith("PEPE")) return formatNumber(price, 6);
        if (price >= 1000) return formatNumber(price, 1);
        return formatNumber(price, 3);
      }
      return formatNumber(price, 6);
    }

    function formatTime(ts) {
      const d = new Date(ts);
      return d.toLocaleTimeString("es-AR", { hour12: false });
    }

    function computeEMA(prevEma, price, k) {
      if (prevEma === null) return price;
      return (price - prevEma) * k + prevEma;
    }

    // ===== DOM =====
    const symbolSelect = document.getElementById("symbolSelect");
    const intervalSelect = document.getElementById("intervalSelect");
    const connectBtn = document.getElementById("connectBtn");

    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");
    const symbolLabel = document.getElementById("symbolLabel");

    const priceValue = document.getElementById("priceValue");
    const priceChange = document.getElementById("priceChange");
    const lastCloseEl = document.getElementById("lastClose");
    const lastCandleInfo = document.getElementById("lastCandleInfo");
    const ema9Value = document.getElementById("ema9Value");
    const ema21Value = document.getElementById("ema21Value");
    const emaState = document.getElementById("emaState");

    const entryStatusEl = document.getElementById("entryStatus");
    const entrySubEl = document.getElementById("entrySub");
    const condEmaEl = document.getElementById("condEma");
    const condUTEl = document.getElementById("condUT");
    const condPriceEl = document.getElementById("condPrice");
    const condAtrEl = document.getElementById("condAtr");
    const condElliottEl = document.getElementById("condElliott");

    const signalTag = document.getElementById("signalTag");
    const signalText = document.getElementById("signalText");
    const signalMeta = document.getElementById("signalMeta");
    const signalsBody = document.getElementById("signalsBody");

    const footerStream = document.getElementById("footerStream");
    const footerPosition = document.getElementById("footerPosition");

    const statSignals = document.getElementById("statSignals");
    const statTrades = document.getElementById("statTrades");
    const statWinrate = document.getElementById("statWinrate");
    const statAvgPnl = document.getElementById("statAvgPnl");

    const candleCanvas = document.getElementById("candleCanvas");

    const notificationsList = document.getElementById("notificationsList");
    const clearNotifBtn = document.getElementById("clearNotifBtn");

    // ===== UI STATE =====
    function setConnectionState(state, message) {
      statusDot.classList.remove("ok", "off");
      if (state === "connected") {
        statusDot.classList.add("ok");
        statusText.textContent = message || "Conectado";
      } else if (state === "connecting") {
        statusText.textContent = message || "Conectandoâ€¦";
      } else if (state === "error") {
        statusDot.classList.add("off");
        statusText.textContent = message || "Error de conexiÃ³n";
      } else {
        statusDot.classList.add("off");
        statusText.textContent = message || "Desconectado";
      }
    }

    function setPriceDisplay(symbol, price) {
      if (price === null) {
        priceValue.textContent = "â€“ â€“ â€“";
        return;
      }
      priceValue.textContent = formatPriceBySymbol(symbol, price);
    }

    function setPriceChangeDisplay(basePrice, currentPrice) {
      if (!basePrice || !currentPrice) {
        priceChange.className = "metric-variation neutral";
        priceChange.innerHTML = '<span class="dot gray"></span> Sin variaciÃ³n';
        return;
      }
      const diff = currentPrice - basePrice;
      const pct = (diff / basePrice) * 100;

      if (Math.abs(pct) < 0.01) {
        priceChange.className = "metric-variation neutral";
        priceChange.innerHTML = '<span class="dot gray"></span> ' + pct.toFixed(2) + "%";
      } else if (pct > 0) {
        priceChange.className = "metric-variation up";
        priceChange.innerHTML = '<span class="dot green"></span> +' + pct.toFixed(2) + "%";
      } else {
        priceChange.className = "metric-variation down";
        priceChange.innerHTML = '<span class="dot red"></span> ' + pct.toFixed(2) + "%";
      }
    }

    function updateEmaDisplay(symbol) {
      ema9Value.textContent = formatPriceBySymbol(symbol, ema9);
      ema21Value.textContent = formatPriceBySymbol(symbol, ema21);

      if (ema9 === null || ema21 === null) {
        emaState.textContent = "Esperando mÃ¡s velas para estabilizar EMAsâ€¦";
        return;
      }

      if (ema9 > ema21) {
        emaState.textContent = "Sesgo EMA alcista (9 > 21)";
      } else if (ema9 < ema21) {
        emaState.textContent = "Sesgo EMA bajista (9 < 21)";
      } else {
        emaState.textContent = "EMAs casi iguales (equilibrio)";
      }
    }

    function setCondPill(el, ok, label) {
      el.classList.remove("ok", "bad");
      el.querySelector("span:nth-child(2)").textContent = label;
      if (ok === null) {
        el.querySelector(".cond-icon").textContent = "â€¢";
        return;
      }
      if (ok) {
        el.classList.add("ok");
        el.querySelector(".cond-icon").textContent = "âœ”";
      } else {
        el.classList.add("bad");
        el.querySelector(".cond-icon").textContent = "âœ–";
      }
    }

    function updateEntryModeUI() {
      entryStatusEl.classList.remove("long", "short", "flat");
      if (entryMode === "ONLY_LONG") {
        entryStatusEl.textContent = "SOLO LONG";
        entryStatusEl.classList.add("long");
        entrySubEl.textContent = "Confluencia principal alcista (EMAs + UT + ATR). Elliott sÃ³lo acompaÃ±a.";
      } else if (entryMode === "ONLY_SHORT") {
        entryStatusEl.textContent = "SOLO SHORT";
        entryStatusEl.classList.add("short");
        entrySubEl.textContent = "Confluencia principal bajista (EMAs + UT + ATR). Elliott sÃ³lo acompaÃ±a.";
      } else {
        entryStatusEl.textContent = "NO OPERAR";
        entryStatusEl.classList.add("flat");
        entrySubEl.textContent = "Falta confluencia dura. Mejor esperar, nada de timbear acÃ¡.";
      }
    }

    function setSignalBanner(type, price, symbol, ts) {
      let cls = "tag-flat";
      let label = "Sin seÃ±al";
      let text = "TodavÃ­a no se alinearon los planetas para entrar.";

      if (type === "BUY") {
        cls = "tag-buy";
        label = "LONG";
        text = "SeÃ±al de entrada LONG por confluencia principal.";
      } else if (type === "SELL") {
        cls = "tag-sell";
        label = "SHORT";
        text = "SeÃ±al de entrada SHORT por confluencia principal.";
      }

      signalTag.className = "tag " + cls;
      signalTag.textContent = label;
      signalText.textContent = text;

      if (type && price != null) {
        signalMeta.textContent =
          `${formatTime(ts)} Â· ${symbol.toUpperCase()} @ ${formatPriceBySymbol(symbol, price)}`;
      } else {
        signalMeta.textContent = "â€“ â€“ â€“";
      }
    }

    function appendSignalRow(type, price, symbol, ema9Val, ema21Val, ts, strategy) {
      const tr = document.createElement("tr");

      const tdTime = document.createElement("td");
      tdTime.textContent = formatTime(ts);
      tr.appendChild(tdTime);

      const tdType = document.createElement("td");
      const badge = document.createElement("span");
      badge.classList.add("badge");
      if (type === "BUY") {
        badge.classList.add("badge-buy");
        badge.textContent = "LONG";
      } else if (type === "SELL") {
        badge.classList.add("badge-sell");
        badge.textContent = "SHORT";
      } else {
        badge.classList.add("badge-flat");
        badge.textContent = "FLAT";
      }
      tdType.appendChild(badge);
      tr.appendChild(tdType);

      const tdStrat = document.createElement("td");
      const stratBadge = document.createElement("span");
      stratBadge.classList.add("badge", "badge-strat");
      stratBadge.textContent = strategy || "ALGO PRO";
      tdStrat.appendChild(stratBadge);
      tr.appendChild(tdStrat);

      const tdPrice = document.createElement("td");
      tdPrice.textContent = formatPriceBySymbol(symbol, price);
      tr.appendChild(tdPrice);

      const tdEma9 = document.createElement("td");
      tdEma9.textContent = formatPriceBySymbol(symbol, ema9Val);
      tr.appendChild(tdEma9);

      const tdEma21 = document.createElement("td");
      tdEma21.textContent = formatPriceBySymbol(symbol, ema21Val);
      tr.appendChild(tdEma21);

      signalsBody.insertBefore(tr, signalsBody.firstChild);
      while (signalsBody.rows.length > 60) {
        signalsBody.deleteRow(signalsBody.rows.length - 1);
      }
    }

    function updatePositionFooter(symbol) {
      if (!openPosition) {
        footerPosition.textContent = "Sin posiciÃ³n abierta";
        return;
      }
      const sideText = openPosition.side === "LONG" ? "LONG" : "SHORT";
      const entry = formatPriceBySymbol(symbol, openPosition.entryPrice);
      footerPosition.textContent =
        `${sideText} @ ${entry} Â· ${formatTime(openPosition.tsEntry)}`;
    }

    function updateStatsUI() {
      const totalSignals = signals.length;
      const totalTrades = trades.length;

      statSignals.textContent = totalSignals;
      statTrades.textContent = totalTrades;

      if (totalTrades === 0) {
        statWinrate.textContent = "â€“";
        statAvgPnl.textContent = "â€“";
        statWinrate.classList.remove("green", "red");
        return;
      }

      const wins = trades.filter(t => t.pnlPct > 0).length;
      const winrate = (wins / totalTrades) * 100;

      let sumPnl = 0;
      for (const t of trades) sumPnl += t.pnlPct;
      const avgPnl = sumPnl / totalTrades;

      statWinrate.textContent = winrate.toFixed(1) + "%";
      statAvgPnl.textContent = avgPnl.toFixed(2) + "%";

      statWinrate.classList.remove("green", "red");
      if (winrate >= 50) statWinrate.classList.add("green");
      else statWinrate.classList.add("red");
    }

    function handleTradeLogic(signalType, price, ts) {
      if (signalType !== "BUY" && signalType !== "SELL") return;
      const sideNew = signalType === "BUY" ? "LONG" : "SHORT";

      if (openPosition && openPosition.side !== sideNew) {
        let pnlPct = 0;
        if (openPosition.side === "LONG") {
          pnlPct = ((price - openPosition.entryPrice) / openPosition.entryPrice) * 100;
        } else if (openPosition.side === "SHORT") {
          pnlPct = ((openPosition.entryPrice - price) / openPosition.entryPrice) * 100;
        }

        trades.push({
          side: openPosition.side,
          entry: openPosition.entryPrice,
          exit: price,
          pnlPct,
          tsEntry: openPosition.tsEntry,
          tsExit: ts
        });

        openPosition = null;
      }

      if (!openPosition) {
        openPosition = {
          side: sideNew,
          entryPrice: price,
          tsEntry: ts
        };
      }

      updatePositionFooter(symbolSelect.value);
      updateStatsUI();
    }

    function registerSignal(type, price, symbol, ema9Val, ema21Val, ts, strategy) {
      signals.push({ type, price, ema9: ema9Val, ema21: ema21Val, ts, strategy });
      appendSignalRow(type, price, symbol, ema9Val, ema21Val, ts, strategy);
      handleTradeLogic(type, price, ts);
      updateStatsUI();
    }

    function resetZigZagState() {
      zzLastDir = null;
      zzLastPrice = null;
      zzLastTime = null;
      zzPivots = [];
      elliottBias = "NEUTRAL";
    }

    // ===== NOTIFICACIONES =====
    function renderNotifications() {
      notificationsList.innerHTML = "";
      if (!notifications.length) {
        const empty = document.createElement("div");
        empty.className = "notif-empty";
        empty.textContent = "Sin notificaciones todavÃ­a.";
        notificationsList.appendChild(empty);
        return;
      }

      for (let i = notifications.length - 1; i >= 0; i--) {
        const n = notifications[i];
        const item = document.createElement("div");
        item.className = "notif-item";

        const badge = document.createElement("span");
        badge.className = "notif-badge " + (n.kind === "LONG" ? "long" : n.kind === "SHORT" ? "short" : "flat");
        badge.textContent = n.kind;

        const body = document.createElement("div");
        body.className = "notif-body";

        const text = document.createElement("div");
        text.className = "notif-text";
        text.textContent = n.message;

        const meta = document.createElement("div");
        meta.className = "notif-meta";
        meta.textContent = `${formatTime(n.ts)} Â· ${n.symbol} Â· ${n.interval}`;

        body.appendChild(text);
        body.appendChild(meta);

        item.appendChild(badge);
        item.appendChild(body);

        notificationsList.appendChild(item);
      }
    }

    function addNotification(kind, message, ts, symbol, interval) {
      notifications.push({ kind, message, ts, symbol, interval });
      if (notifications.length > 30) {
        notifications = notifications.slice(notifications.length - 30);
      }
      renderNotifications();
    }

    function clearNotifications() {
      notifications = [];
      renderNotifications();
    }

    function resetState() {
      closes = [];
      ema9 = null;
      ema21 = null;
      prevEma9 = null;
      prevEma21 = null;
      lastPrice = null;

      atr = null;
      prevClose = null;
      utTrend = null;
      utLine = null;

      signals = [];
      trades = [];
      openPosition = null;

      entryMode = "NO_TRADE";
      prevEntryMode = "NO_TRADE";

      resetZigZagState();

      candles = [];
      notifications = [];
      renderNotifications();

      signalsBody.innerHTML = "";
      lastCloseEl.textContent = "â€“ â€“ â€“";
      lastCandleInfo.textContent = "Esperando datosâ€¦";
      setPriceDisplay(symbolSelect.value, null);
      setPriceChangeDisplay(null, null);
      updateEmaDisplay(symbolSelect.value);

      setCondPill(condEmaEl, null, "EMAs alineadas");
      setCondPill(condUTEl, null, "Tendencia UT");
      setCondPill(condPriceEl, null, "Precio vs EMAs");
      setCondPill(condAtrEl, null, "Volatilidad (ATR)");
      setCondPill(condElliottEl, null, "Elliott (impulso/correcciÃ³n)");
      updateEntryModeUI();

      setSignalBanner(null, null, symbolSelect.value, Date.now());
      updatePositionFooter(symbolSelect.value);
      updateStatsUI();
      drawCandles(); // limpia el canvas
    }

    // ===== ZIGZAG & ELLIOTT (solo info) =====
    function updateZigZag(close, ts) {
      if (zzLastPrice === null) {
        zzLastPrice = close;
        zzLastTime = ts;
        return;
      }

      const change = (close - zzLastPrice) / zzLastPrice;

      if (!zzLastDir) {
        if (Math.abs(change) >= ZZ_THRESHOLD) {
          zzLastDir = change > 0 ? "up" : "down";
        }
        if (change > 0) {
          zzLastPrice = close;
          zzLastTime = ts;
        } else if (change < 0) {
          zzLastPrice = close;
          zzLastTime = ts;
        }
        return;
      }

      if (zzLastDir === "up") {
        if (close >= zzLastPrice) {
          zzLastPrice = close;
          zzLastTime = ts;
        } else {
          const drop = (zzLastPrice - close) / zzLastPrice;
          if (drop >= ZZ_THRESHOLD) {
            zzPivots.push({ type: "H", price: zzLastPrice, time: zzLastTime });
            zzLastDir = "down";
            zzLastPrice = close;
            zzLastTime = ts;
          }
        }
      } else {
        if (close <= zzLastPrice) {
          zzLastPrice = close;
          zzLastTime = ts;
        } else {
          const rise = (close - zzLastPrice) / zzLastPrice;
          if (rise >= ZZ_THRESHOLD) {
            zzPivots.push({ type: "L", price: zzLastPrice, time: zzLastTime });
            zzLastDir = "up";
            zzLastPrice = close;
            zzLastTime = ts;
          }
        }
      }

      while (zzPivots.length > 30) zzPivots.shift();
    }

    function analyzeElliottPattern() {
      if (zzPivots.length < 5) {
        elliottBias = "NEUTRAL";
        setCondPill(condElliottEl, null, "Elliott (pocos pivots)");
        return;
      }

      const last5 = zzPivots.slice(-5);
      let bias = "NEUTRAL";
      let label = "Elliott sin patrÃ³n claro";

      const p0 = last5[0];
      const p1 = last5[1];
      const p2 = last5[2];
      const p3 = last5[3];
      const p4 = last5[4];

      const bullPattern =
        p0.type === "L" &&
        p1.type === "H" &&
        p2.type === "L" &&
        p3.type === "H" &&
        p4.type === "L" &&
        p2.price > p0.price * 1.02 &&
        p4.price >= p2.price * 0.9;

      const bearPattern =
        p0.type === "H" &&
        p1.type === "L" &&
        p2.type === "H" &&
        p3.type === "L" &&
        p4.type === "H" &&
        p2.price < p0.price * 0.98 &&
        p4.price <= p2.price * 1.1;

      if (bullPattern) {
        bias = "BULL";
        label = "Elliott: posible impulso alcista (onda impulsiva)";
      } else if (bearPattern) {
        bias = "BEAR";
        label = "Elliott: posible impulso bajista (onda impulsiva)";
      }

      elliottBias = bias;

      if (bias === "BULL" || bias === "BEAR") {
        setCondPill(condElliottEl, true, label);
      } else {
        setCondPill(condElliottEl, false, "Elliott sin patrÃ³n claro (no bloquea entradas)");
      }
    }

    // ===== CONFLUENCIA DURA (EMAs + UT + ATR) =====
    function recomputeEntryModeAndSignals(close, symbol, ts) {
      if (
        ema9 === null ||
        ema21 === null ||
        atr === null ||
        utTrend === null ||
        utLine === null
      ) {
        setCondPill(condEmaEl, null, "EMAs alineadas");
        setCondPill(condUTEl, null, "Tendencia UT");
        setCondPill(condPriceEl, null, "Precio vs EMAs");
        setCondPill(condAtrEl, null, "Volatilidad (ATR)");
        entryMode = "NO_TRADE";
        updateEntryModeUI();
        return;
      }

      const emaBull = ema9 > ema21;
      const emaBear = ema9 < ema21;
      const utLong = utTrend === "LONG";
      const utShort = utTrend === "SHORT";
      const priceAboveEMAs = close > ema9 && close > ema21;
      const priceBelowEMAs = close < ema9 && close < ema21;
      const minAtr = close * ATR_MIN_PCT;
      const enoughVol = atr >= minAtr;

      setCondPill(
        condEmaEl,
        emaBull || emaBear,
        "EMAs alineadas (" + (emaBull ? "alcista" : emaBear ? "bajista" : "neutro") + ")"
      );
      setCondPill(
        condUTEl,
        utLong || utShort,
        "Tendencia UT (" + (utLong ? "LONG" : utShort ? "SHORT" : "flat") + ")"
      );
      setCondPill(
        condPriceEl,
        priceAboveEMAs || priceBelowEMAs,
        "Precio vs EMAs"
      );
      setCondPill(
        condAtrEl,
        enoughVol,
        "Volatilidad ATR â‰¥ " + (ATR_MIN_PCT * 100).toFixed(2) + "%"
      );

      const longCore = emaBull && utLong && priceAboveEMAs && enoughVol;
      const shortCore = emaBear && utShort && priceBelowEMAs && enoughVol;

      prevEntryMode = entryMode;

      if (longCore && !shortCore) {
        entryMode = "ONLY_LONG";
      } else if (shortCore && !longCore) {
        entryMode = "ONLY_SHORT";
      } else {
        entryMode = "NO_TRADE";
      }

      updateEntryModeUI();

      if (prevEntryMode !== entryMode) {
        const interval = intervalSelect.value.toUpperCase();
        // Noti + sonido SOLO cuando pasamos a SOLO_LONG / SOLO_SHORT
        if (entryMode === "ONLY_LONG") {
          const msg = "Cambio a modo SOLO LONG (confluencia alcista).";
          addNotification("LONG", msg, ts, symbol.toUpperCase(), interval);
          setSignalBanner("BUY", close, symbol, ts);
          registerSignal("BUY", close, symbol, ema9, ema21, ts, "ALGO PRO");
          playAlert("BUY");
        } else if (entryMode === "ONLY_SHORT") {
          const msg = "Cambio a modo SOLO SHORT (confluencia bajista).";
          addNotification("SHORT", msg, ts, symbol.toUpperCase(), interval);
          setSignalBanner("SELL", close, symbol, ts);
          registerSignal("SELL", close, symbol, ema9, ema21, ts, "ALGO PRO");
          playAlert("SELL");
        } else {
          // Volvimos a NO_TRADE -> avisamos, pero sin duplicar sonido
          const msg = "Salida de confluencia. Modo NO OPERAR.";
          addNotification("FLAT", msg, ts, symbol.toUpperCase(), interval);
          if (openPosition) {
            const sideExitSignal = openPosition.side === "LONG" ? "SELL" : "BUY";
            handleTradeLogic(sideExitSignal, close, ts);
          }
          setSignalBanner(null, null, symbol, ts);
        }
      }
    }

    // ===== GRÃFICO DE VELAS =====
    function drawCandles() {
      if (!candleCanvas) return;
      const ctx = candleCanvas.getContext("2d");
      if (!ctx) return;

      const dpr = window.devicePixelRatio || 1;
      const rect = candleCanvas.getBoundingClientRect();
      const width = rect.width * dpr;
      const height = rect.height * dpr;
      candleCanvas.width = width;
      candleCanvas.height = height;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Fondo
      ctx.fillStyle = "#050814";
      ctx.fillRect(0, 0, rect.width, rect.height);

      if (!candles.length) {
        ctx.fillStyle = "#6b7280";
        ctx.font = "11px system-ui";
        ctx.fillText("Esperando velasâ€¦", 10, 20);
        return;
      }

      const padLeft = 40;
      const padRight = 8;
      const padTop = 8;
      const padBottom = 20;
      const w = rect.width;
      const h = rect.height;

      // Rango de precios
      let minP = Infinity;
      let maxP = -Infinity;
      for (const c of candles) {
        if (c.low < minP) minP = c.low;
        if (c.high > maxP) maxP = c.high;
      }
      if (!isFinite(minP) || !isFinite(maxP)) return;
      if (minP === maxP) {
        minP *= 0.99;
        maxP *= 1.01;
      }

      const priceRange = maxP - minP;
      const pxPerPrice = (h - padTop - padBottom) / priceRange;

      function yFromPrice(price) {
        return padTop + (maxP - price) * pxPerPrice;
      }

      // Grid horizontal + labels
      ctx.strokeStyle = "#1f2933";
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.font = "10px system-ui";
      ctx.fillStyle = "#9ca3af";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";

      const gridLines = 4;
      for (let i = 0; i <= gridLines; i++) {
        const frac = i / gridLines;
        const p = minP + frac * priceRange;
        const y = yFromPrice(p);
        ctx.beginPath();
        ctx.moveTo(padLeft, y);
        ctx.lineTo(w - padRight, y);
        ctx.stroke();
        ctx.fillText(formatNumber(p, 4), 4, y);
      }
      ctx.setLineDash([]);

      // Dibujar velas
      const n = candles.length;
      const drawableWidth = w - padLeft - padRight;
      const step = drawableWidth / Math.max(n, 1);
      const bodyWidth = Math.max(3, step * 0.6);

      for (let i = 0; i < n; i++) {
        const c = candles[i];
        const xCenter = padLeft + i * step + step / 2;

        const yHigh = yFromPrice(c.high);
        const yLow = yFromPrice(c.low);
        const yOpen = yFromPrice(c.open);
        const yClose = yFromPrice(c.close);

        const isBull = c.close >= c.open;
        const color = isBull ? "#0ecb81" : "#f6465d";

        // mecha
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(xCenter, yHigh);
        ctx.lineTo(xCenter, yLow);
        ctx.stroke();

        // cuerpo
        const bodyTop = Math.min(yOpen, yClose);
        const bodyBottom = Math.max(yOpen, yClose);
        const bodyHeight = Math.max(1, bodyBottom - bodyTop);

        ctx.fillStyle = color;
        ctx.fillRect(
          xCenter - bodyWidth / 2,
          bodyTop,
          bodyWidth,
          bodyHeight
        );
      }
    }

    // ===== HISTÃ“RICO =====
    async function loadInitialKlines(symbol, interval) {
      const url =
        `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=80`;
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();

        closes = [];
        candles = [];
        atr = null;
        prevClose = null;
        utTrend = null;
        utLine = null;
        resetZigZagState();

        const K_EMA9 = 2 / (9 + 1);
        const K_EMA21 = 2 / (21 + 1);

        for (let i = 0; i < data.length; i++) {
          const row = data[i];
          const open = parseFloat(row[1]);
          const high = parseFloat(row[2]);
          const low = parseFloat(row[3]);
          const close = parseFloat(row[4]);
          const closeTime = row[6];

          closes.push(close);
          candles.push({ open, high, low, close, time: closeTime });

          if (i === data.length - 1) lastPrice = close;

          // ATR
          let tr;
          if (prevClose === null) {
            tr = high - low;
            atr = tr;
          } else {
            tr = Math.max(
              high - low,
              Math.abs(high - prevClose),
              Math.abs(low - prevClose)
            );
            atr = atr === null
              ? tr
              : ((atr * (ATR_PERIOD - 1)) + tr) / ATR_PERIOD;
          }
          prevClose = close;

          // EMAs
          ema9 = computeEMA(ema9, close, K_EMA9);
          ema21 = computeEMA(ema21, close, K_EMA21);

          // UT style
          if (utLine === null) {
            utLine = close;
            utTrend = "FLAT";
          } else {
            if (close > utLine) {
              utTrend = "LONG";
              utLine = Math.max(utLine, close - ATR_MULT * atr);
            } else if (close < utLine) {
              utTrend = "SHORT";
              utLine = Math.min(utLine, close + ATR_MULT * atr);
            }
          }

          updateZigZag(close, closeTime);
          analyzeElliottPattern();
          if (i > ATR_PERIOD) {
            recomputeEntryModeAndSignals(close, symbol, closeTime);
          }
        }

        // Limitar velas
        if (candles.length > MAX_CANDLES) {
          candles = candles.slice(candles.length - MAX_CANDLES);
        }

        setPriceDisplay(symbol, lastPrice);
        setPriceChangeDisplay(closes[0], lastPrice);
        updateEmaDisplay(symbol);
        lastCloseEl.textContent = formatPriceBySymbol(symbol, lastPrice);
        lastCandleInfo.textContent =
          `HistÃ³rico precargado (${closes.length} velas)`;

        drawCandles();
      } catch (err) {
        console.error("Error al cargar klines:", err);
        lastCandleInfo.textContent =
          "Error al precargar velas: " + (err && err.message ? err.message : err);
      }
    }

    // ===== STREAM EN VIVO =====
    function connectStream() {
      const symbol = symbolSelect.value.toUpperCase();
      const interval = intervalSelect.value;

      resetState();
      symbolLabel.textContent = `${symbol} Â· ${interval.toUpperCase()}`;
      footerStream.textContent = `${symbol.toLowerCase()}@kline_${interval}`;

      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.close(1000, "Reset connection");
      }

      setConnectionState("connecting", "Cargando velas inicialesâ€¦");

      loadInitialKlines(symbol, interval).then(() => {
        const streamName = `${symbol.toLowerCase()}@kline_${interval}`;
        const url = `wss://stream.binance.com/ws/${streamName}`;

        try {
          socket = new WebSocket(url);
        } catch (e) {
          console.error("Error creando WebSocket:", e);
          setConnectionState("error", "No se pudo crear WebSocket");
          return;
        }

        socket.onopen = () => {
          setConnectionState("connected", "Conectado a Binance");
        };

        socket.onclose = () => {
          setConnectionState("disconnected", "ConexiÃ³n cerrada");
        };

        socket.onerror = (ev) => {
          console.error("WebSocket error:", ev);
          setConnectionState("error", "Error de conexiÃ³n (ver consola)");
        };

        socket.onmessage = (event) => {
          const data = JSON.parse(event.data);
          const k = data.k;
          const open = parseFloat(k.o);
          const close = parseFloat(k.c);
          const high = parseFloat(k.h);
          const low = parseFloat(k.l);
          const isFinal = k.x;
          const openTime = k.t;
          const closeTime = k.T;
          lastPrice = close;

          setPriceDisplay(symbol, lastPrice);
          if (closes.length > 0) {
            setPriceChangeDisplay(closes[0], lastPrice);
          }

          // Actualizar velas para el grÃ¡fico
          if (isFinal) {
            closes.push(close);
            if (closes.length > 400) closes.shift();

            // ATR
            let tr;
            if (prevClose === null) {
              tr = high - low;
              atr = tr;
            } else {
              tr = Math.max(
                high - low,
                Math.abs(high - prevClose),
                Math.abs(low - prevClose)
              );
              atr = atr === null
                ? tr
                : ((atr * (ATR_PERIOD - 1)) + tr) / ATR_PERIOD;
            }
            prevClose = close;

            // EMAs
            const K_EMA9 = 2 / (9 + 1);
            const K_EMA21 = 2 / (21 + 1);

            prevEma9 = ema9;
            prevEma21 = ema21;

            ema9 = computeEMA(ema9, close, K_EMA9);
            ema21 = computeEMA(ema21, close, K_EMA21);
            updateEmaDisplay(symbol);

            lastCloseEl.textContent = formatPriceBySymbol(symbol, close);
            lastCandleInfo.textContent =
              `Vela cerrada Â· ${formatTime(closeTime)} Â· Vol: ${parseFloat(k.v).toFixed(3)}`;

            // UT
            if (utLine === null) {
              utLine = close;
              utTrend = "FLAT";
            } else {
              if (close > utLine) {
                utTrend = "LONG";
                utLine = Math.max(utLine, close - ATR_MULT * atr);
              } else if (close < utLine) {
                utTrend = "SHORT";
                utLine = Math.min(utLine, close + ATR_MULT * atr);
              }
            }

            // Cerrar vela en array
            candles.push({ open, high, low, close, time: closeTime });
            if (candles.length > MAX_CANDLES) {
              candles = candles.slice(candles.length - MAX_CANDLES);
            }

            updateZigZag(close, closeTime);
            analyzeElliottPattern();
            recomputeEntryModeAndSignals(close, symbol, closeTime);
            drawCandles();
          } else {
            // Vela en curso: actualizamos la Ãºltima o la creamos
            if (!candles.length) {
              candles.push({ open, high, low, close, time: closeTime });
            } else {
              const last = candles[candles.length - 1];
              if (last.time === closeTime) {
                last.open = open;
                last.high = high;
                last.low = low;
                last.close = close;
              } else {
                candles.push({ open, high, low, close, time: closeTime });
                if (candles.length > MAX_CANDLES) {
                  candles = candles.slice(candles.length - MAX_CANDLES);
                }
              }
            }
            lastCandleInfo.textContent =
              `Vela en curso Â· ${formatTime(openTime)} â†’ ${formatTime(closeTime)}`;
            drawCandles();
          }
        };
      });
    }

    // ===== EVENTOS UI =====
    connectBtn.addEventListener("click", () => {
      initAudio();
      connectStream();
    });
    symbolSelect.addEventListener("change", connectStream);
    intervalSelect.addEventListener("change", connectStream);
    window.addEventListener("load", connectStream);
    window.addEventListener("resize", drawCandles);
    clearNotifBtn.addEventListener("click", clearNotifications);

    // Render inicial para que aparezca el mensaje vacÃ­o
    renderNotifications();
  </script>
</body>
</html>


